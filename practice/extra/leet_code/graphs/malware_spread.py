# Minimize Malware Spread

# You are given a network of n nodes represented as an n x n adjacency matrix graph, where the i
# th node is directly connected to the jth node if graph[i][j] == 1.

# Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and
# at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread
# of malware will continue until no more nodes can be infected in this manner.

# Suppose M(initial) is the final number of nodes infected with malware in the entire network after the
# spread of malware stops. We will remove exactly one node from initial.

# Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to
# minimize M(initial), return such a node with the smallest index.

# Note that if a node was removed from the initial list of infected nodes, it might still be infected
# later due to the malware spread.


# w kazdej skladowej odpalamy dfs
# jesli znajdziemy 2 wierzcholki w spojnej skladowej, to odpusczamy (zmiana na nieskazony nic nie da)
# jesli znajdziemy jeden, ktory jest skazony, to bierzemy skladowa pod uwage



def malware_spread(graph, initial):

    n = len(graph)
    visited = [False] * n
    infected = [False] * n

    for infected_v in initial:
        infected[infected_v] = True

    def dfs_visit(u):                       # vertices - liczba wierzcholkow w spojnej skladowej,
                                            # c trzyma liczbe wierzcholkow wierzcholkow skazonych
        nonlocal vertices, c, idx
        visited[u] = True
        vertices += 1
        if infected[u]:
            idx = u
            c += 1

        for v in range(n):
            if graph[u][v] and not visited[v]:
                dfs_visit(v)

    saved = 0
    res_idx = float("inf")

    for u in range(n):
        if not visited[u]:
            vertices, c, idx = 0, 0, float("inf")
            dfs_visit(u)
            if c == 1 and saved < vertices:
                saved = vertices
                res_idx = idx
            elif c == 1 and saved == vertices:                       # jesli uratujemy tyle samo, to szukamy min indeksu sposrod reszty
                res_idx = min(res_idx, idx)

    if res_idx == float("inf"):                                      # przypadek  (zaden nie ratuje)
        for u in range(n):
            if infected[u]: return u

    return res_idx



graph1 = [[1, 1, 0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 0, 0, 0, 0, 0, 0],
          [0, 1, 1, 1, 0, 1, 0, 0, 0],
          [0, 0, 1, 1, 1, 0, 0, 0, 0],
          [0, 0, 0, 1, 1, 0, 0, 0, 0],
          [0, 0, 1, 0, 0, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 1, 1],
          [0, 0, 0, 0, 0, 0, 1, 1, 0],
          [0, 0, 0, 0, 0, 0, 1, 0, 1]]

initials1 = [1, 2, 6]
# Expected: 6

graph2 = [[1,1,0],[1,1,0],[0,0,1]]
initials2 = [0,1]
# Expected: 0

graph3 = [[1,0,1,0],[0,1,0,1],[1,0,1,0],[0,1,0,1]]
initials3 = [2,1]
# Expected: 1

# print(malware_spread(graph1, initials1))
# print(malware_spread(graph2, initials2))
# print(malware_spread(graph3, initials3))

